# Volatile全解读

## 定义
- 轻量级的synchronized
- 适用于读多写少的情况
- 通过保证可见性和禁止指令重排序来确保所有线程看到这个变量值是一致的

## 如何保证可见性
使用了volatile修饰的变量在转成汇编代码时，会有一个Lock前缀的指令。
这个Lock指令在多核处理器的情况下引发了两件事情：
1. 将当前处理器缓存行的数据写回到主存中
2. 这个写回到主存的动作会触发其他处理器的对应地址的缓存行的数据无效。

### Lock信号
在旧的处理器上Lock信号会直接独占主存，锁总线。
在新的处理上，不直接锁总线，而是通过MESI缓存一致性协议，只锁定缓存上所在的区域。

### 如何使得其他CPU的缓存行失效
处理器的嗅探技术保证缓存的一致性，使得缓存行失效，强制执行缓存行填充

## Volatile缓存行优化示例
并发包里的Linked-TransferQueue
由于处理器缓存行一般为64字节长度的问题，如果队列的head节点和tail节点在同一个缓存行，那么出队和入会导致节点修改会导致严重的性能问题。
因此，将头尾节点强行填充到64字节宽，避免了首尾节点处于同一个缓存行的问题。

## 如何实现禁止指令重排序
内存屏障

### 保守策略下的4条规则
1. Volatile写前插入一个StoreStore屏障，禁止写重排序
2. Volatile写后插入一个StoreLoad屏障
3. Volatile读后插入一个LoadLoad屏障，禁止读重排序
4. Volatile读后插入一个LoadStore屏障

### 保守情况下Volatile屏障示意图

### 实际Volatile屏障示意图(非保守策略)

## Volatile的语义增强
###为什么需要限制Volatile与普通读写的执行顺序
旧的JMM模型没有限制Volatile变量与普通变量的重排序，因此可能导致问题。
新的JSR-133对此进行了增强，限制了Volatile与普通变量的指令重排序：
1.当第二个操作时Volatile写，第一个操作不允许重排序，确保volatile写之前的操作不会被排序到写之后
2.当第一个操作是volatile读时，第二个操作不允许重排序，保证volatile读之后的操作不会被排序到读之前

## 双重检查锁与Volatile
### 双重检查锁的问题
在多线程环境下，由于创建示例new指令内部的指令重排序，导致示例未初始化完成，但是已经分配了指针，其他线程在拿到指针后，实际上实例并未初始化完成，这可能导致问题。

*****new指令实际步骤**
1. 申请内存空间
2. 对象在内存中初始化
3. 放回内存地址指针给到变量

### 如何解决双重检查锁的问题
1. 使用Volatile修饰变量。禁止指令重排序保证实例的完整初始化
2. 使用静态内部类，利用类初始化的同步锁，保证类创建的原子性
