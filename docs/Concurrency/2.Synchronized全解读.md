# Synchronized全解读

## 基本用法
- 普通方法
- 静态方法
- 代码块
锁的对象不同。

## 特性
- 有序性
- 可见性
- 原子性
- 可重入性

> 什么是可见性

指的是多个线程在访问同一个资源时，该资源的状态对于其他线程都是可见。
其中synchronized对一个类或者对象加锁时，其他线程要访问该类或者对象都需要先获取锁，而这个锁的状态对于其他线程都是可见的，并且线程在释放锁的时候，都会先将对变量的修改刷新到共享内存中。

## 偏向锁
### 偏向锁的对象头
![](../../images/xxx.png)

### 偏向锁的使用前提
1. JDK1.6以上
2. 偏向锁的开启默认具有延时，可通过JVM启动参数取消延时
3. 被加锁的对象没有显式或者隐式计算过Hashcodo

### 偏向锁的定义
偏向锁使用了一种等到竞争才释放锁的机制，当出现其他线程竞争偏向锁的，持有偏向锁的线程才会释放锁。
偏向锁的撤销，需要等到线程到达全局安全点(没有正在执行的字节码)。
1. 检查持有偏向锁的线程是否还是alive状态
2. 如果线程已死亡，则将对象头设置成无锁状态
3. 如果还活着，将持有偏向锁的栈中的锁记录和对象头的markword要么变成无锁状态，要么偏向于其他线程，或者变成其他锁。

### 偏向锁示例
> 场景一

1. A线程获取偏向锁
2. A线程死亡退出
3. B线程争取偏向锁，会直接升级当前的偏向锁，变成轻量级锁(只争抢了一次)
4. B线程释放锁，锁对象变成无锁状态

> 场景二

1. A线程获取偏向锁
2. B线程来争抢锁(A线程还在同步块内)
3. 锁对象直接升级成重量锁

> 场景三

1. A线程获取偏向锁
2. A线程执行完同步代码块，但是未死亡
3. B线程争抢锁
4. 锁对象升级成轻量级锁

### 偏向锁的撤销
> 批量重偏向

当同一个线程多次争取偏向锁，默认前面20次升级成轻量级锁，当次数到达阈值时，会变成偏向锁，直接偏向线程。(JVM成人之美)

> 批量撤销

如果基于批量重偏向的基础上，如果出现新的第三条线程，还在进行争抢，这时候就会触发批量撤销。JVM会标记该类新创建的对象直接就是轻量级锁，而不是偏向锁。这个是真正的锁升级。

> 锁升级

偏向锁升级成轻量级锁：真正的锁升级指的是class所产生的任意对象，而不是针对单个实例对象。
轻量级锁升级成重量级锁：依赖于当前对象。

## 轻量级锁
### 轻量级锁的加锁过程
1. JVM在栈帧中开辟一个Lock Record，记录锁对象的markword(hashcode,epoch,is偏向锁)
2. 尝试cas替换锁对象的markword，替换成Lock Record的指针
3. 如果失败，自旋重试
### 轻量级锁的解锁过程
1. 尝试cas将markword替换回对象头
2. 如果失败，膨胀成重量级锁
### 轻量级锁膨胀过程
1. 线程2 cas自旋没有拿到锁，将锁对象的对象头的markword轻量级指针修改掉
2. 线程1释放锁发现变成了重量级锁
3. 初始化monitor对象
4. 将自身持有的markword设置到monitor的header属性
5. 将锁设置成重量级锁状态，并将前30位指向monitor对象
6. 唤醒线程2
7. 开始争抢锁，非公平锁

## 死锁
> 如何避免死锁

1. 避免一个线程获取多个锁
2. 使用定时锁
3. 避免一个锁占用多个资源

## ObjectMonitor
> 五个重要属性

1. header：放置重量级锁的markword
2. own：锁持有的线程id
3. cxq队列：第一次竞争失败的线程
4. EntryList队列：同步队列，后续竞争失败的线程
5. waitSet：等待队列，调用了wait方法的线程
