# 阻塞与非阻塞队列

## ConcurrentLinkQueue

### 特点
1. 使用的非阻塞算法，CAS
2. 无界
3. tail节点不总为尾节点，取决于添加节点时，tail.next是否为Null，head节点同理

### 阻塞队列

### 7个阻塞队列
- ArrayBlockingQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- DelayQueue
- SychronousQueue
- LinkedTransferQueue
- LinkedBlockingDeque

### ArrayBlockingQueue 和 LinkedBlockingQueue
- 都是FIFO
- 都是有界
- 都是阻塞队列

> 不同点

1. 锁不同，ArrayBlockingQueue使用一把lock，LinkedBlockingQueue使用了两把锁，put和take各一把，更适合高并发，有更高的吞吐量。
2. LinkedBlockingQueue由于需要保存Node节点和next指针，对象比较多，存在GC的消耗和内存空间占用更多
3. 队列长度问题，ArrayQueue使用前需要指定定长的空间。

> 哪个效率更高

视情况而定。
1. **最好基于压测，性能测试**。
2. 写多读少，由于Node不适合太多，建议arrayQueue
3. 读多写少，建议linkedQueue
4. 定长，建议arrayQueue
5. 数量很大，建议arrayQueue

### PriorityQueue
- 无界
- 默认自然排序，可定义CompareTo方法

### DelayQueue
> 场景

1. 缓存系统的缓存过期（比较少用）
2. 定时调度任务

> 使用

1. 自定义任务对象，实现delayed接口，重写getDelay和compareTo方法

> 底层实现

底层实现为优先级队列

offer():插入数据并唤醒take阻塞的线程

poll():非阻塞，取不到立刻返回

take():阻塞等待

### sychronousQueue
不存储任何元素的阻塞队列，默认非公平，也支持公平
