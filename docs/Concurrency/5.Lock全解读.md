# Lock全解读

## 如何实现一个自定义lock
利用Lock接口和AQS实现一个自定义锁并测试

## Lock特性
与synchronized相比，Lock的使用更加灵活
1. 可以尝试非阻塞的获取锁，获取不到，立刻失败
2. 获取到锁的线程支持响应中断，并释放锁
3. 能够超时等待锁，避免死锁

## AQS(同步器)

### 底层实现
一个FIFO的双端队列，同时使用一个int成员变量表示同步状态。
同步器本身没有实现任何接口，利用了模板模式调用使用者继承同步器重写的5个方法。
1. 获取独占锁
2. 释放独占锁
3. 获取共享锁
4. 释放共享锁
5. 是否被线程持有
同时同步器提供过3个关于同步状态的方法
1. 获取状态
2. 设置状态
3. CAS设置状态，保证状态设置的原子性

### 同步队列AQS为什么在插入尾节点时需要使用CAS
竞争失败的线程可能是多个，插入同步队列时，需要保证多线程插入的安全性

## ReentrantLock
### 获取锁的流程(lock)
1. 获取同步状态
2. 获取失败进入等待队列，插入尾节点(CAS)
3. 不断自检，判断线程Node状态，signal、cancel、other。
### 流程图

### 超时获取锁(tryLock)
1. 获取同步状态
2. 设置超时时间线
3. 不断获取锁，并且自检响应中断
