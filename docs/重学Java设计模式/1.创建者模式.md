# 创建者模式

## 工厂模式
### 背景
需要根据不同的店铺采用不同的发送积分策略

### 不使用模式
大量的的if-else代码直接堆砌在调用层

### 使用工厂模式例子
1. 定义发送积分接口，统一入参和出参
2. 各个子类实现不同的发送积分策略
3. 定义工厂，根据店铺标识，获取不同的子类，返回接口类型
4. 接口类型调用发送积分方法

### 好处
1. 避免了了创建者和具体的发送积分逻辑耦合，避免了大量的if-else代码
2. 无需修改调用者的代码就可以引入新的策略

### 缺陷
子类数量可能会迅速膨胀

### 总结
核心在于解决接口选择问题

## 抽象工厂
### 背景
Redis缓存集群升级，选择不同的redis服务，类不同，接口名称也不同

## 建造者
### 背景
装修，基本物料不会变，组合经常会变，提供不同的装修方案

### 不使用模式
根据接口传参，直接在客户端硬编码，计算价格和展示装修方案

### 使用建造者模式
1. 接口定义每种物料的选择
2. 统一物料基类
3. 实现接口，封装价格和装修方案
4. 使用建造者封装各种方案
5. 客户端直接使用不同的建造方案

### 好处
独立建造者，易于扩展

### 缺陷
当物料增加，或者组合方式增加，类膨胀。可以将组合配置到数据库，减少大量代码。

## 原型
### 背景
输出不同顺序考题的考卷

### 不适用模式
直接在客户端创建考题和考卷，支持乱序会导致类更加膨胀

### 使用原型模式
1. 考题初始化
2. clone
3. 乱序

### 好处
在一些对象的创建过程比较麻烦的场景，使用clone避免重复创建对象

### 缺陷
需要深度克隆，如果类中包含引用，更加复杂，可能导致循环引用的clone

## 单例
### 背景
1. 数据库连接池的创建
2. Spring bean的初始化与消费

### 不使用模式
重复创建相同的实例，浪费内存与性能

### 使用模式
1. 静态类
2. 懒汉，加锁
3. 饿汉，静态类
4. 静态内部类，懒加载
5. 双重校验锁
6. AtomicRef，CAS忙等待创建
7. 枚举

### 好处
提高了性能，降低了内存使用

### 缺陷
无

### 总结
注意线程安全

注意加载时机

